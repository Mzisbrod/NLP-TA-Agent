[
  {
    "context": "Homework 2 question 1: Reading the grammar and getting started. The class Pcfg represents a PCFG grammar in chomsky normal form. To instantiate a Pcfg object, you need to pass a file object to the constructor, which contains the data. You can then access the instance variables of the Pcfg instance to get information about the rules. The dictionary lhs_to_rules maps left-hand-side (lhs) symbols to lists of rules. Each rule in the list is represented as (lhs, rhs, probability) triple. The rhs_to_rules dictionary contains the same rules as values, but indexed by right-hand-side",
    "statements": [
      {
        "source": "Write the method verify_grammar, that checks that the grammar is a valid PCFG in Chomsky Normal form. Specifically you need to verify that each rule corresponds to one of the formats permitted in CNF. To do this, you can assume that the lhs symbols of the rules make up the inventory of nonterminals. Any other symbol should be interpreted as a terminal. \nYou also need to ensure all probabilities for the same lhs symbol sum to 1.0 (approximately). Then change the main section of grammar.py to read in the grammar, print out a confirmation if the grammar is a valid PCFG in CNF or print an error message if it is not. You should now be able to run grammar.py on grammars and verify that they are well formed for the CKY parser.",
        "target": "    def verify_grammar(self):\n        \"\"\"\n        Return True if the grammar is a valid PCFG in CNF.\n        Otherwise return False. \n        \"\"\"\n        for lh, rules_list in self.lhs_to_rules.items():\n            if not lh.isupper():\n                return False\n            for rule in rules_list:\n                if len(rule[1]) > 2:\n                    return False\n                elif len(rule[1]) == 2 and not all(s.isupper() for s in rule[1]):\n                    return False\n            # check probability of lhs\n            if round(fsum([rule[-1] for rule in rules_list]),5) != 1.0:\n                return False\n        return True"
      }
    ]
    },
  {
    "context": "Homework 2 question 2: Membership checking with CKY. The file cky.py already contains a class CkyParser. When a CkyParser instance is created a grammar instance is passed to the constructor. The instance variable grammar can then be used to access this Pcfg object.",
    "statements": [
      {
        "source": "Write the method is_in_language(self, tokens) by implementing the CKY algorithm. Your method should read in a list of tokens and return True if the grammar can parse this sentence and False otherwise. While parsing, you will need to access the dictionary self.grammar.rhs_to_rules. You can use any data structure you want to represent the parse table (or read ahead to question 3 of this assignment, where a specific data structure is prescribed)",
        "target": "    def is_in_language(self,tokens):\n        \"\"\"\n        Membership checking. Parse the input tokens and return True if \n        the sentence is in the language described by the grammar. Otherwise\n        return False\n        \"\"\"\n        chart = [[set() for i in range(len(tokens) + 1)] for i in range(len(tokens) + 1)]\n        for i in range(len(tokens)):\n            s = tokens[i]\n            if (s,) in self.grammar.rhs_to_rules:\n                chart[i][i+1] = set([rule[0] for rule in self.grammar.rhs_to_rules[(s,)]])\n        for l in range(2, len(tokens) + 1):\n            for i in range(len(tokens)-l+1):\n                j = i + l\n                for k in range(i+1, j):\n                    B_set = chart[i][k]\n                    C_set = chart[k][j]\n                    for B in B_set:\n                        for C in C_set:\n                            if (B, C) in self.grammar.rhs_to_rules:\n                                chart[i][j] = chart[i][j].union(set([rule[0] for rule in self.grammar.rhs_to_rules[(B, C)]]))\n        if self.grammar.startsymbol in chart[0][len(tokens)]:\n            return True\n        return False"
      }
    ]
  },
  {
    "context": "Homework 2 question 3: Parsing with backpointers. The parsing method in part 2 can identify if a string is in the language of the grammar, but it does not produce a parse tree. It also does not take probabilities into account. You will now extend the parser so that it retrieves the most probable parse for the input sentence, given the PCFG probabilities in the grammar. The first object is parse table containing backpointers, represented as a dictionary (this is more convenient in Python than a 2D array). The keys of the dictionary are spans, for example table[(0,3)]  retrieves the entry for span 0 to 3 from the chart. The values of the dictionary should be dictionaries that map nonterminal symbols to backpointers. For example: table[(0,3)]['NP'] returns the backpointers to the table entries that were used to create the NP phrase over the span 0 and 3. For example, the value of table[(0,3)]['NP'] could be ((\"NP\",0,2),(\"FLIGHTS\",2,3)). This means that the parser has recognized an NP covering the span 0 to 3, consisting of another NP from 0 to 2 and FLIGHTS from 2 to 3. The split recorded in the table at table[(0,3)]['NP'] is the one that results in the most probable parse for the span [0,3] that is rooted in NP. \nTerminal symbols in the table could just be represented as strings. For example the table entry for table[(2,3)][\"FLIGHTS\"] should be \"flights\".\n\nThe second object is similar, but records log probabilities instead of backpointers. For example the value of probs[(0,3)]['NP'] might be -12.1324. This value represents the log probability of the best parse tree (according to the grammar) for the span 0,3 that results in an NP. During parsing, when you fill an entry on the backpointer parse table and iterate throught the possible splits for a (span/nonterminal) combination, that entry on the table will contain the back-pointers for the the current-best split you have found so far. For each new possible split, you need to check if that split would produce a higher log probability. If so, you update the entry in the backpointer table, as well as the entry in the probability table. \n\nAfter parsing has finished, the table entry table[0,len(toks)][grammar.startsymbol] will contain the best backpointers for the left and right subtree under the root node. probs[0,len(toks)][grammar.startsymbol] will contain the total log-probability for the best parse. \n\ncky.py contains two test functions check_table_format(table) and check_prob_format(probs) that you can use to make sure the two table data structures are formatted correctly. Both functions should return True. Note that passing this test does not guarantee that the content of the tables is correct, just that the data structures are probably formatted correctly.",
    "statements": [
        {
          "source": "Write the method parse_with_backpointers(self, tokens). You should modify your CKY implementation from part 2, but use (and return) specific data structures. The method should take a list of tokens as input and returns a) the parse table b) a probability table. Both objects should be constructed during parsing. They replace whatever table data structure you used in part 2.",
          "target": "    def parse_with_backpointers(self, tokens):\n        \"\"\"\n        Parse the input tokens and return a parse table and a probability table.\n        \"\"\"\n        chart = defaultdict(dict)\n        probs = defaultdict(lambda: defaultdict(int))\n        for i in range(len(tokens)):\n            s = tokens[i]\n            if (s,) in self.grammar.rhs_to_rules:\n                for rule in self.grammar.rhs_to_rules[(s,)]:\n                    chart[(i,i+1)][rule[0]] = rule[1][0]\n                    probs[(i,i+1)][rule[0]] = math.log(rule[2])\n\n        for l in range(2, len(tokens) + 1):\n            for i in range(len(tokens)-l+1):\n                j = i + l\n                for k in range(i+1, j):\n                    B_set = chart[(i,k)]\n                    C_set = chart[(k,j)]\n                    for B, B_rule in B_set.items():\n                        for C, C_rule in C_set.items():\n                            for rule in self.grammar.rhs_to_rules[(B, C)]:\n                                prob = math.log(rule[2]) + probs[(i,k)][rule[1][0]] + probs[(k,j)][rule[1][1]]\n                                if rule[0] not in probs[(i,j)] or prob > probs[(i,j)][rule[0]]:\n                                    probs[(i,j)][rule[0]] = prob\n                                    chart[(i,j)][rule[0]] = ((rule[1][0],i,k), (rule[1][1],k,j))\n        return chart, probs"
        }
    ]
  },
  {
    "context": "Homework 2 question 4: Retrieving a parse tree. You now have a working parser, but in order to evaluate its performance we still need to reconstruct a parse tree from the backpointer table returned by parse_with_backpointers. Note that the intended format is the same as the data in the treebank. Each tree is represented as tuple where the first element is the parent node and the remaining elements are children. Each child is either a tree or a terminal string. \n\nHint: Recursively traverse the parse chart to assemble this tree",
    "statements": [
        {
          "source": "Write the function get_tree(chart, i,j, nt) which should return the parse-tree rooted in non-terminal nt and covering span i,j.",
          "target": "def get_tree(chart, i,j,nt): \n    \"\"\"\n    Return the parse-tree rooted in non-terminal nt and covering span i,j.\n    \"\"\"\n    if i<j and j-i == 1:\n        return (nt, chart[(i,j)][nt])\n\n    children = chart[(i, j)][nt]\n    return (nt, get_tree(chart, children[0][1], children[0][2], children[0][0]), get_tree(chart, children[1][1], children[1][2], children[1][0]))"
        }
    ]
  },
  {
    "context": "Homework 2 question 5: Evaluating the parser. The program evaluate_parser.py evaluates your parser by comparing the output trees to the trees in the test data set. The program imports your CKY parser class. It then reads in the test file line-by-line. For each test tree, it extracts the yield of the tree (i.e. the list of leaf nodes). It then feeds this list as input to your parser, obtains a parse chart, and then retrieves the predicted tree by calling your get_tree method. It then compares the predicted tree against the target tree in the following way (this is a standard approach to evaluating constiuency parsers, called PARSEVAL): \nFirst it obtains a set of the spans in each tree (including the nonterminal label). It then computes precision, recall, and F-score (which is the harmonic mean between precision and recall) between these two sets. The script finally reports the coverage (percentage of test sentences that had any parse), the average F-score for parsed sentences, and the average F-score for all sentences (including 0 f-scores for unparsed sentences). \n\n",
    "statements": [
        {
          "source": "What should the results on the atis3 test corpus be?",
          "target": "Coverage: 67%, Average F-score (parsed sentences): 0.95, Average F-score (all sentences): 0.64"
        }
    ]
  }
]